id = 001, first
title_text = 245a:LNK245a
subtitle_text = 245b:LNK245b
title_added_entry_text = 700t:710t:711t
series_title_text = 440a:490a:800a:830a
notes_text = 500a:505a:590a
uniform_title_text = 130a:240a
alternate_form_title_text = 246abinp

title_display = custom, removeTrailingPunct(245a)
title_facet = custom, getSortableTitle
# getSortableTitle - internally calls get title, which concatenates 245a and 245b fields, 
#                    then the routine strips off a number of initial characters based on the
#                    the values found in the Marc indicators.  Lastly the routine transforms the 
#                    title to all lower case. 
subtitle_display = custom, removeTrailingPunct(245b)
responsibility_statement_display = custom, removeTrailingPunct(245c)
linked_responsibility_statement_display = LNK245c
title_added_entry_display = custom, removeTrailingPunct(700t)
uniform_title_facet = custom, removeTrailingPunct(130a:240a)
linked_title_display = LNK245ab
alternate_form_title_facet = custom, removeTrailingPunct(246abinp)
part_text = 245np
part_display = custom, removeTrailingPunct(245np)

author_text = 100abcdeq4:110abcdeq4:111abcdeq4:130abcdeq4:LNK100abcdeq4:LNK110abcdeq4:LNK111abcdeq4:LNK130abcdeq4
author_display = custom, removeTrailingPunct(100abcdeq4:110abcdeq4:111abcdeq4)
linked_author_display = LNK100ab:LNK110a:LNK111a:LNK700a:LNK710a:LNK711a
author_added_entry_text = 700a:710a:711a

published_text = 260abc
published_display = custom, removeTrailingPunct(260abc)
published_date_display = custom, getPublicationDate
# getPublicationDate - retrieves characters 7 - 10 from 008 field, characters 11 - 14 from 008 field
#                      and the contents of the 260c field, and looks at all three values to try to determine
#                      the single best 4 digit year value to return as the "publication date" of the item.
published_date_facet = custom, getPubDateGroups(pub_date_range_map.properties)
# getPubDateGroups - starts with the four digit year value returned by getPublicationDate (see above)
#                    and uses that date to map to one or more descriptive strings such as: "This year",
#                    "Last 3 years", "Last 10 years", "Last 50 years", and "More than 50 years ago"
material_type_text = 300a
marc_display = FullRecordAsXML
marc_text = custom, getAllSearchableFields(100, 900)
# getAllSearchableFields - returns ALL fields and all associated subfields with a field tag greater or 
#                          equal to 100 and less than 900 
year_multisort_i = custom, getPublicationDate
# (see comment with published_date_display above)
isbn_text = 020a, (pattern_map.isbn_clean)
# pattern_map.isbn_clean - takes the contents of the 020a subfield, and returns the initial segment 
#                          of it consisting of digits, spaces and dashes.
issn_text = 022a, (pattern_map.isbn_clean)
isbn_display = 020a, (pattern_map.isbn_clean)
issn_display = 022a, (pattern_map.isbn_clean)
oclc_text = 035a, (pattern_map.oclc_num)
url_display = custom, getLabelledURL("")
# getLabelledURL - grabs all 856 u fields, if there is a z subfield use that as a label, otherwise use the default.

subject_text = 600a:610a:611a:630a:650a:651a:655a:690a

#call_number_broad_facet = custom, getCallNumberPrefix(callnumber_map.properties, 1)
#call_number_facet = custom, getCallNumberPrefix(callnumber_map.properties, 0)
#call_number_text = custom, getCallNumbersCleaned(999ai';', false)
#call_number_display = custom, getCallNumbersCleaned(999ai';', true)
#call_number_sort_facet = custom, getCallNumberCleaned(999a, sortable)
call_number_broad_facet = custom, getCallNumberPrefixNew(callnumber_map.properties, 1)
# getCallNumberPrefixNew - selects a single 'best' LC callnumber from the 999a subfield and the 050ab subfields
#                          and then uses the callnumber_map to map only the first letter of the LC call number
#                          to the broad LC subject description for that single letter.
call_number_facet = custom, getCallNumberPrefixNew(call_number_detail_map.properties, 0)
# getCallNumberPrefixNew - as above, selects a single 'best' LC callnumber from the 999a subfield and the 050ab subfields
#                          but then uses the a different, more detailed callnumber_map to map the first two letters of 
#                          the first letter of the LC call number to a more detailed LC subject description.  Additionally
#                          for a few two letter combinations, (E, F, GV, PN and Z) the number following the initial letters
#                          are used to further refine the LC subject description. 
#                          to the broad description for that single letter.
call_number_text = custom, getCallNumbersCleanedNew(false)
# getCallNumbersCleanedNew - gather all call numbers from 999a subfields and if none of them are LC numbers also grabs the
#                            value in the 050ab subfields.  This list is then simply returned and all of the call numbers are
#                            indexed for searching.
call_number_display = custom, getCallNumbersCleanedNew(true)
# getCallNumbersCleanedNew - gather all call numbers from 999a subfields and if none of them are LC numbers also grabs the
#                            value in the 050ab subfields.  This list is then sorted, and similar call numbers are grouped
#                            together, so that the two call numbers: CD05939 v.1  and CD05939 v.2  would produce a single output
#                            string of:  CD05939 v.1, v.2
#                            Note that the dev index uses a modified version of this routine that doesn't include call numbers
#                            from the 050 field.
call_number_sort_facet = custom, getCallNumberCleanedNew(sortable)
# getCallNumberCleanedNew - as above, selects a single 'best' callnumber from the 999a subfield and the 050ab subfields
#                           If this 'best' call number is a LC call number, it will be expanded with leading zeroes to make 
#                           sorting of the call numbers work better.

author_facet = custom, removeTrailingPunct(100abcdeq4:110abcdeq4:111abcdenq4:130abcdeq4)
barcode_facet = 999i
subject_facet = custom, getAllSubfields(600[a-z]:610[a-z]:611[a-z]:630[a-z]:650[a-z]:651[a-z]:655[a-z]:690[a-z], " -- ")
series_title_facet = custom, removeTrailingPunct(440a:490a:800a:830a)
date_indexed_facet = DateRecordIndexed
source_facet = "Library Catalog"
subject_era_facet = custom, removeTrailingPunct(650d:650y:651y:655y)
topic_form_genre_facet = custom, removeTrailingPunct(650a:650b:650x:655a)
region_facet = custom, removeTrailingPunct(650z:651a)
format_facet = custom, getCombinedFormatNew
#  Complicated routine, hard to summarize, here's the code.
#    public Set<String> getCombinedFormatNew(final Record record)
#    {    
#        String mapName1 = loadTranslationMap(null, "format_maps.properties(broad_format)");
#        String mapName1a = loadTranslationMap(null, "format_maps.properties(broad_format_electronic)");
#        String mapName2 = loadTranslationMap(null, "format_maps.properties(format_007)");
#        String mapName3 = loadTranslationMap(null, "format_maps.properties(format)");
#
#        Set<String> result = getFieldList(record, "999t");
#        result = Utils.remap(result, findMap(mapName3), false);
#
#        Set<String> f245h = getFieldList(record, "245h");
#        if (Utils.setItemContains(f245h, "cartographic material"))
#        {
#            result.add("Map");
#        }
#        Set<String> urls = getFieldList(record, "856u");
#        Set<String> format_007_raw = getFieldList(record, "007[0-1]");
#        if (Utils.setItemContains(format_007_raw, "cr") || Utils.setItemContains(result, "Online"))
#        {
#            String other007 = null;
#            String broadFormat = getFirstFieldVal(record, null, "000[6-7]");
#            if (format_007_raw.size() >= 1)
#            {
#                for (String str007 : format_007_raw)
#                {
#                    if (!str007.equals("cr"))
#                    {
#                        other007 = str007;
#                        break;
#                    }
#                }
#            }
#            if (other007 != null && other007.startsWith("v")) 
#            {
#                result.add(Utils.remap("v", findMap(mapName1a), true)); // Streaming Video
#                result.add(Utils.remap("v", findMap(mapName2), true));  // Video
#            }
#            else if (broadFormat.equals("am")) 
#            {
#                result.add(Utils.remap("am", findMap(mapName1a), true)); // eBook
#                result.add(Utils.remap("a", findMap(mapName1), true));  // Book
#            }
#            else if (broadFormat.equals("as"))
#            {
#                result.add(Utils.remap("as", findMap(mapName1a), true)); // Online
#                result.add(Utils.remap("as", findMap(mapName1), true));  // Journal/Magazine
#            }
#            else if (broadFormat.startsWith("m"))
#            {
#                result.add(Utils.remap("m", findMap(mapName1), true));
#            }
#        }
#        else if (Utils.setItemContains(urls, "serialssolutions"))
#        {
#            String serialsFormat = Utils.remap("as", findMap(mapName1), true);
#            if (serialsFormat != null) result.add(serialsFormat);
#        }
#        else
#        {
#            String format_007 = getFirstFieldVal(record, mapName2, "007[0]");
#            if (format_007 != null) 
#            {
#                result.add(format_007);
#            }
#            else 
#            {
#                String broadFormat = getFirstFieldVal(record, mapName1, "000[6-7]:000[6]");
#                if (broadFormat != null) result.add(broadFormat);
#            }
#        }
#        return(result);
#    }
format_orig_facet = custom, getCombinedFormat
# getCombinedFormat - previous format routine, only kept around as a reference.
language_facet = custom, getCustomLanguage(language_map.properties)
# getCustomLanguage - looks in characters 35 - 37 of field 008 for primary language. Also looks in 041a d h and b to list 
#                     languages that the item is "translated from" or "dubbed in" or "subtitled in" or "has summary in"
location_facet = custom, getCustomLocation(location_map.properties, shadowed_location_map.properties, library_map.properties)
library_facet = 999m, library_map.properties
instrument_facet = 048a[0-1], instrument_map.properties
recording_type_facet = 000[6], (map.recording_type)
recordings_and_scores_facet = custom, getRecordingAndScore
# getRecordingAndScore - looks in character 6 of the leader.  If there is a 'c' or 'd' return both "Scores" and
#                        "Recordings and/or Scores". If there is a 'j' return both "Recordings" and
#                        "Recordings and/or Scores". 
recording_format_facet = custom, getRecordingFormat, format_maps.properties(recording_format)
# getRecordingFormat - looks in character 6 of the leader.  If there is a 'i' or 'j' or ir field 245h contains "videorecording"
#                      then grab all 999t subfields, map them via the map format_maps.properties(recording_format) and return them.
music_catagory_facet = 999a[0-1]:999a[0], music_maps.properties(music_catagory), first
ports_of_call_facet = 650c:650z:651a:651x:651z:655z, semester_at_sea.properties(port_of_call)
guide_book_facet = 651v, (pattern_map.guide_book)
composition_era_facet = custom, getEra, composition_era_map.properties
# getEra - looks in the 045a subfield, and then maps the two character codes found there to the decade/century to which they refer.

#shadowed_location_facet = custom, getShadowedLocation(shadowed_location_map.properties(shadowed), returnHIDDEN, extraIds)
#shadowed_location_facet = customDeleteRecordIfFieldEmpty, getShadowedLocation(shadowed_location_map.properties, deleteHIDDEN, noExtraIds)
shadowed_location_facet = custom, getShadowedLocation(shadowed_location_map.properties, returnHIDDEN, extraIds)
# getShadowedLocation - looks at the 999 field in l and k subfields, matches the values there against the shadowed_location_map
#                       if all holdings for a particular item are mapped to HIDDEN then the record itself is hidden from view.
#                       Additionally this routine uses a static list from Chris Hobeke to determine when when particular items or
#                       holdings for a particular item are marked as "shadowed" within the Virgo system. (Which isn't noted anywhere
#                       within the Marc records themselves. 




map.recording_type.j = Musical
map.recording_type.i = Non-Musical

pattern_map.stripPunct.pattern_0 = ^(.*?[^ ]) *[,/;:= ]*$=>$1
pattern_map.stripPunct.pattern_1 = ^(.+((\\p{L}|\\p{N})\\p{M}?(\\p{L}|\\p{N})\\p{M}?))\\. *$=>$1
pattern_map.stripPunct.pattern_2 = ^\\[(.+)\\]$=>$1
pattern_map.stripPunct.pattern_3 = ^\\[([^]]+)?$=>$1
pattern_map.stripPunct.pattern_4 = ^([^\\[]+)\\]$=>$1
pattern_map.stripPunct.pattern_5 = ^(.+)$=>$1


pattern_map.guide_book.pattern_0 = Guidebook=>Guidebook

pattern_map.oclc_num.pattern_0 = .*\\(OCoLC\\)(.*)=>$1

pattern_map.call_num.pattern_0 = ([A-Za-z]*).*=>$1
pattern_map.call_num1.pattern_0 = ([^|]*)\\|.*=>$1
pattern_map.call_num2.pattern_0 = [^|]*\\|(.*)=>$1

pattern_map.isbn_clean.pattern_0 = ([- 0-9]*[0-9]).*=>$1